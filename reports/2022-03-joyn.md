![Joyn](/static/684f9032eced42db17daca58185260fc/34ca5/joyn.png)

Joyn contest  
Findings & Analysis Report
=========================================

#### 2022-07-25

Table of contents
-----------------

*   [Overview](#overview)
    
    *   [About C4](#about-c4)
    *   [Wardens](#wardens)
*   [Summary](#summary)
*   [Scope](#scope)
*   [Severity Criteria](#severity-criteria)
*   [High Risk Findings (9)](#high-risk-findings-9)
    
    *   [\[H-01\] ERC20 transferFrom return values not checked](#h-01-erc20-transferfrom-return-values-not-checked)
    *   [\[H-02\] Splitter: Anyone can call incrementWindow to steal the tokens in the contract](#h-02-splitter-anyone-can-call-incrementwindow-to-steal-the-tokens-in-the-contract)
    *   [\[H-03\] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker](#h-03-dos-claimforallwindows-may-be-made-unusable-by-an-attacker)
    *   [\[H-04\] CoreCollection can be reinitialized](#h-04-corecollection-can-be-reinitialized)
    *   [\[H-05\] Centralisation RIsk: Owner Of `RoyaltyVault` Can Take All Funds](#h-05-centralisation-risk-owner-of-royaltyvault-can-take-all-funds)
    *   [\[H-06\] STORAGE COLLISION BETWEEN PROXY AND IMPLEMENTATION (LACK EIP 1967)](#h-06-storage-collision-between-proxy-and-implementation-lack-eip-1967)
    *   [\[H-07\] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it](#h-07-duplicate-nfts-can-be-minted-if-payabletoken-has-a-callback-attached-to-it)
    *   [\[H-08\] Funds cannot be withdrawn in `CoreCollection.withdraw`](#h-08-funds-cannot-be-withdrawn-in-corecollectionwithdraw)
    *   [\[H-09\] ERC20 tokens with no return value will fail to transfer](#h-09-erc20-tokens-with-no-return-value-will-fail-to-transfer)
*   [Medium Risk Findings (12)](#medium-risk-findings-12)
    
    *   [\[M-01\] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert](#m-01-dos-attacker-may-front-run-createsplit-with-a-merkleroot-causing-future-transactions-with-the-same-merkleroot-to-revert)
    *   [\[M-02\] Fixed Amount of Gas Sent in Call May Be Insufficient](#m-02-fixed-amount-of-gas-sent-in-call-may-be-insufficient)
    *   [\[M-03\] `RoyaltyVault.sol` is Not Equipped to Handle On-Chain Royalties From Secondary Sales](#m-03-royaltyvaultsol-is-not-equipped-to-handle-on-chain-royalties-from-secondary-sales)
    *   [\[M-04\] createProject can be frontrun](#m-04-createproject-can-be-frontrun)
    *   [\[M-05\] Gas costs will likely result in any fees sent to the Splitter being economically unviable to recover.](#m-05-gas-costs-will-likely-result-in-any-fees-sent-to-the-splitter-being-economically-unviable-to-recover)
    *   [\[M-06\] CoreCollection’s token transfer can be disabled](#m-06-corecollections-token-transfer-can-be-disabled)
    *   [\[M-07\] Ineffective Handling of FoT or Rebasing Tokens](#m-07-ineffective-handling-of-fot-or-rebasing-tokens)
    *   [\[M-08\] CoreCollection: Starting index is pseudo-randomly generated, allowing for gameable NFT launches](#m-08-corecollection-starting-index-is-pseudo-randomly-generated-allowing-for-gameable-nft-launches)
    *   [\[M-09\] Differing percentage denominators causes confusion and potentially brick claims](#m-09-differing-percentage-denominators-causes-confusion-and-potentially-brick-claims)
    *   [\[M-10\] Add a timelock to `setPlatformFee()`](#m-10-add-a-timelock-to-setplatformfee)
    *   [\[M-11\] Not handling return value of transferFrom command can create inconsistency](#m-11-not-handling-return-value-of-transferfrom-command-can-create-inconsistency)
    *   [\[M-12\] `CoreCollection.setRoyaltyVault` doesn’t check `royaltyVault.royaltyAsset` against `payableToken`, resulting in potential permanent lock of `payableTokens` in royaltyVault](#m-12-corecollectionsetroyaltyvault-doesnt-check-royaltyvaultroyaltyasset-against-payabletoken-resulting-in-potential-permanent-lock-of-payabletokens-in-royaltyvault)
*   [Low Risk and Non-Critical Issues](#low-risk-and-non-critical-issues)
*   [Gas Optimizations](#gas-optimizations)
    
    *   [G-01 `require()`/`revert()` strings longer than 32 bytes cost extra gas](#g-01-requirerevert-strings-longer-than-32-bytes-cost-extra-gas)
    *   [G-02 Use a more recent version of solidity](#g-02-use-a-more-recent-version-of-solidity)
    *   [G-03 Use a more recent version of solidity](#g-03-use-a-more-recent-version-of-solidity)
    *   [G-04 Using `bool`s for storage incurs overhead](#g-04-using-bools-for-storage-incurs-overhead)
    *   [G-05 Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement](#g-05-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-statement)
    *   [G-06 `<array>.length` should not be looked up in every loop of a `for`\-loop](#g-06-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop)
    *   [G-07 It costs more gas to initialize variables to zero than to let the default of zero be applied](#g-07-it-costs-more-gas-to-initialize-variables-to-zero-than-to-let-the-default-of-zero-be-applied)
    *   [G-08 State variables should be cached in stack variables rather than re-reading them from storage](#g-08-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage)
    *   [G-09 Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas](#g-09-using-calldata-instead-of-memory-for-read-only-arguments-in-external-functions-saves-gas)
    *   [G-10 `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in `for`\- and `while`\-loops](#g-10-ii-should-be-uncheckediuncheckedi-when-it-is-not-possible-for-them-to-overflow-as-is-the-case-when-used-in-for--and-while-loops)
    *   [G-11 `++i` costs less gas than `++i`, especially when it’s used in `for`\-loops (`--i`/`i--` too)](#g-11-i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too)
    *   [G-12 Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead](#g-12-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead)
    *   [G-13 Using `private` rather than `public` for constants, saves gas](#g-13-using-private-rather-than-public-for-constants-saves-gas)
    *   [G-14 Don’t compare boolean expressions to boolean literals](#g-14-dont-compare-boolean-expressions-to-boolean-literals)
    *   [G-15 Remove unused variables](#g-15-remove-unused-variables)
    *   [G-16 State variables only set in the constructor should be declared `immutable`](#g-16-state-variables-only-set-in-the-constructor-should-be-declared-immutable)
    *   [G-17 `require()` or `revert()` statements that check input arguments should be at the top of the function](#g-17-require-or-revert-statements-that-check-input-arguments-should-be-at-the-top-of-the-function)
    *   [G-18 `private` functions not called by the contract should be removed to save deployment gas](#g-18-private-functions-not-called-by-the-contract-should-be-removed-to-save-deployment-gas)
    *   [G-19 `public` functions not called by the contract should be declared `external` instead](#g-19-public-functions-not-called-by-the-contract-should-be-declared-external-instead)
    *   [G-20 Use custom errors rather than `revert()`/`require()` strings to save deployment gas](#g-20-use-custom-errors-rather-than-revertrequire-strings-to-save-deployment-gas)
    *   [G-21 Functions guaranteed to revert when called by normal users can be marked `payable`](#g-21-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable)
*   [Disclosures](#disclosures)

[](#overview)Overview
=====================

[](#about-c4)About C4
---------------------

Code4rena (C4) is an open organization consisting of security researchers, auditors, developers, and individuals with domain expertise in smart contracts.

A C4 audit contest is an event in which community participants, referred to as Wardens, review, audit, or analyze smart contract logic in exchange for a bounty provided by sponsoring projects.

During the audit contest outlined in this document, C4 conducted an analysis of the Joyn smart contract system written in Solidity. The audit contest took place between March 30—April 1 2022.

[](#wardens)Wardens
-------------------

45 Wardens contributed reports to the Joyn contest:

1.  [leastwood](https://twitter.com/0xleastwood)
2.  [kirk-baird](https://twitter.com/kirkthebaird)
3.  peritoflores
4.  [hickuphh3](https://twitter.com/HickupH)
5.  [ych18](https://www.linkedin.com/in/yahia-chaabane/)
6.  [wuwe1](https://twitter.com/wuwe19)
7.  hyh
8.  [rayn](https://twitter.com/rayn731)
9.  [WatchPug](https://twitter.com/WatchPug_) ([jtp](https://github.com/jack-the-pug) and [ming](https://github.com/mingwatch))
10.  [Dravee](https://twitter.com/JustDravee)
11.  [Ruhum](https://twitter.com/0xruhum)
12.  hubble (ksk2345 and shri4net)
13.  [TomFrenchBlockchain](https://github.com/TomAFrench)
14.  robee
15.  [defsec](https://twitter.com/defsec_)
16.  [CertoraInc](https://twitter.com/CertoraInc) (egjlmn1, [OriDabush](https://twitter.com/ori_dabush), ItayG, and shakedwinder)
17.  saian
18.  IllIllI
19.  0x ([Czar102](https://twitter.com/_Czar102) and [pmerkleplant](https://twitter.com/merkleplant_eth))
20.  0xDjango
21.  [pedroais](https://twitter.com/Pedroais2/)
22.  minhquanym
23.  m9800
24.  [rfa](https://www.instagram.com/riyan_rfa/)
25.  0xkatana
26.  kenta
27.  [BouSalman](https://twitter.com/BouSalman)
28.  [z3s](https://github.com/z3s/)
29.  [securerodd](https://twitter.com/securerodd)
30.  cccz
31.  [0v3rf10w](https://twitter.com/_0v3rf10w)
32.  0x1f8b
33.  hake
34.  Hawkeye (0xwags and 0xmint)
35.  [Tomio](https://twitter.com/meidhiwirara)
36.  [Funen](https://instagram.com/vanensurya)
37.  blackswordsman
38.  [0xNazgul](https://twitter.com/0xNazgul)

This contest was judged by [Michael De Luca](https://github.com/deluca-mike).

Final report assembled by [itsmetechjay](https://twitter.com/itsmetechjay).

[](#summary)Summary
===================

The C4 analysis yielded an aggregated total of 21 unique vulnerabilities. Of these vulnerabilities, 9 received a risk rating in the category of HIGH severity and 12 received a risk rating in the category of MEDIUM severity.

Additionally, C4 analysis included 25 reports detailing issues with a risk rating of LOW severity or non-critical. There were also 21 reports recommending gas optimizations.

All of the issues presented here are linked back to their original finding.

[](#scope)Scope
===============

The code under review can be found within the [C4 Joyn contest repository](https://github.com/code-423n4/2022-03-joyn), and is composed of 10 smart contracts written in the Solidity programming language and includes 1,294 lines of Solidity code.

[](#severity-criteria)Severity Criteria
=======================================

C4 assesses the severity of disclosed vulnerabilities according to a methodology based on [OWASP standards](https://owasp.org/www-community/OWASP_Risk_Rating_Methodology).

Vulnerabilities are divided into three primary risk categories: high, medium, and low/non-critical.

High-level considerations for vulnerabilities span the following key areas when conducting assessments:

*   Malicious Input Handling
*   Escalation of privileges
*   Arithmetic
*   Gas use

Further information regarding the severity criteria referenced throughout the submission review process, please refer to the documentation provided on [the C4 website](https://code4rena.com).

[](#high-risk-findings-9)High Risk Findings (9)
===============================================

[](#h-01-erc20-transferfrom-return-values-not-checked)[\[H-01\] ERC20 transferFrom return values not checked](https://github.com/code-423n4/2022-03-joyn-findings/issues/52)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by hickuphh3, also found by 0xDjango, kirk-baird, leastwood, m9800, minhquanym, and pedroais_

The `transferFrom()` function returns a boolean value indicating success. This parameter needs to be checked to see if the transfer has been successful. Oddly, `transfer()` function calls were checked.

Some tokens like [EURS](https://etherscan.io/address/0xdb25f211ab05b1c97d595516f45794528a807ad8#code) and [BAT](https://etherscan.io/address/0x0d8775f648430679a709e98d2b0cb6250d2887ef#code) will **not** revert if the transfer failed but return `false` instead. Tokens that don’t actually perform the transfer and return `false` are still counted as a correct transfer.

### [](#impact)Impact

Users would be able to mint NFTs for free regardless of mint fee if tokens that don’t revert on failed transfers were used.

### [](#recommended-mitigation-steps)Recommended Mitigation Steps

Check the `success` boolean of all `transferFrom()` calls. Alternatively, use OZ’s `SafeERC20`’s `safeTransferFrom()` function.

**[sofianeOuafir (Joyn) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/52#issuecomment-1099284756):**

> In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk)
> 
> This is clearly an issue that needs to be fixed and represents a high risk. Currently, the current state of the code would allow users to mint tokens even if the payment isn’t successful.

**[deluca-mike (judge) increased severity to High and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/52#issuecomment-1105345001):**

> `payableToken` seems to be defined by whomever defines the `Collection` in `createProject`, so it would be possible for that person to define a payable token that, unbeknownst to them, behaves unexpectedly. I agree with high risk (unless there is some person/committee that is curates and validates the `paybaleToken`s ahead of time). Need to handle return from `transfer` and `transferFrom`, as well as erc20s that do not return anything from from `transfer` and `transferFrom`.

* * *

[](#h-02-splitter-anyone-can-call-incrementwindow-to-steal-the-tokens-in-the-contract)[\[H-02\] Splitter: Anyone can call incrementWindow to steal the tokens in the contract](https://github.com/code-423n4/2022-03-joyn-findings/issues/3)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by cccz, also found by hickuphh3, kirk-baird, leastwood, pedroais, rayn, Ruhum, saian, WatchPug, and wuwe1_

In general, the Splitter contract’s incrementWindow function is only called when tokens are transfer to the contract, ensuring that the number of tokens stored in balanceForWindow is equal to the contract balance. However, anyone can use a fake RoyaltyVault contract to call the incrementWindow function of the Splitter contract, so that the amount of tokens stored in balanceForWindow is greater than the contract balance, after which the verified user can call the claim or claimForAllWindows functions to steal the tokens in the contract.

        function incrementWindow(uint256 royaltyAmount) public returns (bool) {
            uint256 wethBalance;
    
            require(
                IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
                "Royalty Vault not supported"
            );
            require(
                IRoyaltyVault(msg.sender).getSplitter() == address(this),
                "Unauthorised to increment window"
            );
    
            wethBalance = IERC20(splitAsset).balanceOf(address(this));
            require(wethBalance >= royaltyAmount, "Insufficient funds");
    
            require(royaltyAmount > 0, "No additional funds for window");
            balanceForWindow.push(royaltyAmount);
            currentWindow += 1;
            emit WindowIncremented(currentWindow, royaltyAmount);
            return true;
        }

### [](#proof-of-concept)Proof of Concept

[https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169](https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L149-L169)

### [](#recommended-mitigation-steps-1)Recommended Mitigation Steps

Add the onlyRoyaltyVault modifier to the incrementWindow function of the Splitter contract to ensure that only RoyaltyVault contracts with a specific address can call this function.

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/3#issuecomment-1099540074):**

> This is a high-risk issue and we intend to solve it. The mitigation provided looks good too and will be considered when fixing this issue 👍

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/3#issuecomment-1105975952):**

> See a detailed exploit and recommended solution at #21

* * *

[](#h-03-dos-claimforallwindows-may-be-made-unusable-by-an-attacker)[\[H-03\] DoS: `claimForAllWindows()` May Be Made Unusable By An Attacker](https://github.com/code-423n4/2022-03-joyn-findings/issues/6)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by kirk-baird, also found by hyh and Ruhum_

When the value of `currentWindow` is raised sufficiently high `Splitter.claimForAllWindows()` will not be able to be called due to the block gas limit.

`currentWindow` can only ever be incremented and thus will always increase. This value will naturally increase as royalties are paid into the contract.

Furthermore, an attacker can continually increment `currentWindow` by calling `incrementWindow()`. An attacker can impersonate a `IRoyaltyVault` and send 1 WEI worth of WETH to pass the required checks.

### [](#proof-of-concept-1)Proof of Concept

Excerpt from `Splitter.claimForAllWindows()` demonstrating the for loop over `currentWindow` that will grow indefinitely.

            for (uint256 i = 0; i < currentWindow; i++) {
                if (!isClaimed(msg.sender, i)) {
                    setClaimed(msg.sender, i);
    
                    amount += scaleAmountByPercentage(
                        balanceForWindow[i],
                        percentageAllocation
                    );
                }
            }

`Splitter.incrementWindow()` may be called by an attacker increasing `currentWindow`.

        function incrementWindow(uint256 royaltyAmount) public returns (bool) {
            uint256 wethBalance;
    
            require(
                IRoyaltyVault(msg.sender).supportsInterface(IID_IROYALTY),
                "Royalty Vault not supported"
            );
            require(
                IRoyaltyVault(msg.sender).getSplitter() == address(this),
                "Unauthorised to increment window"
            );
    
            wethBalance = IERC20(splitAsset).balanceOf(address(this));
            require(wethBalance >= royaltyAmount, "Insufficient funds");
    
            require(royaltyAmount > 0, "No additional funds for window");
            balanceForWindow.push(royaltyAmount);
            currentWindow += 1;
            emit WindowIncremented(currentWindow, royaltyAmount);
            return true;
        }

### [](#recommended-mitigation-steps-2)Recommended Mitigation Steps

Consider modifying the function `claimForAllWindows()` to instead claim for range of windows. Pass the function a `startWindow` and `endWindow` and only iterate through windows in that range. Ensure that `endWindow < currentWindow`.

**[sofianeOuafir (Joyn) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/6#issuecomment-1099542295):**

> In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk) duplicate of #3

**[deluca-mike (judge) increased severity to High and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/6#issuecomment-1105926348):**

> While similar, I believe these issues are separate.
> 
> Issue 3 indicates that the check that `msg.sender` is an authorized `RoyaltyVault` is faulty, since any contract can implement the interface and return the `Splitter` from `getSplitter`. While this should be fixed, as the warden suggested in the Recommended Mitigation Steps in #3, the issue raised in this issue can still occur when enough authorized `RoyaltyVault` contracts call `incrementWindow`.
> 
> `claimForAllWindows` can remain, but as this warden suggests, a `claimForWindows(uint256 startWindow, uint256 endWindow, uint256 percentageAllocation, bytes32[] calldata merkleProof)` should exist, in case `claimForAllWindows` becomes prohibitively expensive, even organically (i.e. `currentWindow` is made very high due to sufficient authorized `incrementWindow` calls).

* * *

[](#h-04-corecollection-can-be-reinitialized)[\[H-04\] CoreCollection can be reinitialized](https://github.com/code-423n4/2022-03-joyn-findings/issues/4)
---------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by hyh, also found by 0xkatana, hubble, kirk-baird, leastwood, pedroais, rayn, rfa, Ruhum, saian, securerodd, and WatchPug_

Reinitialization is possible for CoreCollection as `initialize` function sets `initialized` flag, but doesn’t control for it, so the function can be rerun multiple times.

Such types of issues tend to be critical as all core variables can be reset this way, for example `payableToken`, which provides a way to retrieve all the contract funds.

However, setting priority to be medium as `initialize` is `onlyOwner`. A run by an external attacker this way is prohibited, but the possibility of owner initiated reset either by mistake or with a malicious intent remains with the same range of system breaking consequences.

### [](#proof-of-concept-2)Proof of Concept

`initialize` doesn’t control for repetitive runs:

[https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87](https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L87)

### [](#recommended-mitigation-steps-3)Recommended Mitigation Steps

Add `onlyUnInitialized` modifier to the `initialize` function:

[https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46-L49](https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L46-L49)

**[sofianeOuafir (Joyn) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/4#issuecomment-1099562776):**

> This is a high severity issue and we intend to fix it. The mitigation step looks great and will be considered to fix the issue.
> 
> In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk)

**[deluca-mike (judge) increased severity to High and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/4#issuecomment-1105941622):**

> Not convinced this is a high severity issue, since erroneously changing `payableToken` via a re-initialization can simply be corrected by a re-re-initialization to set it back correctly. Further, as the warden mentioned, the initialize function is behind `onlyOwner`.
> 
> However, if it can be shown that users other than the owner can end up losing value due to the owner abusing or erroneously using `initialize`, then it can be promoted to High Severity.
> 
> And just as I say that, #17 points that out clearly. So, yes, agreed, this is a High Severity issue.

* * *

[](#h-05-centralisation-risk-owner-of-royaltyvault-can-take-all-funds)[\[H-05\] Centralisation RIsk: Owner Of `RoyaltyVault` Can Take All Funds](https://github.com/code-423n4/2022-03-joyn-findings/issues/9)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by kirk-baird, also found by 0xDjango, defsec, Dravee, hubble, hyh, leastwood, minhquanym, Ruhum, TomFrenchBlockchain, and WatchPug_

The owner of `RoyaltyVault` can set `_platformFee` to any arbitrary value (e.g. 100% = 10000) and that share of the contracts balance and future balances will be set to the `platformFeeRecipient` (which is in the owners control) rather than the splitter contract.

As a result the owner can steal the entire contract balance and any future balances avoiding the splitter.

### [](#proof-of-concept-3)Proof of Concept

        function setPlatformFee(uint256 _platformFee) external override onlyOwner {
            platformFee = _platformFee;
            emit NewRoyaltyVaultPlatformFee(_platformFee);
        }

### [](#recommended-mitigation-steps-4)Recommended Mitigation Steps

This issue may be mitigated by add a maximum value for the `_platformFee` say 5% (or some reasonable value based on the needs of the platform).

Also consider calling `sendToSplitter()` before adjusting the `platformFee`. This will only allow the owner to change the fee for future value excluding the current contract balance.

Consider the following code.

        function setPlatformFee(uint256 _platformFee) external override onlyOwner {
            require(_platformFee < MAX_FEE);
            sendToSplitter(); // @audit this will need to be public rather than external
            platformFee = _platformFee;
            emit NewRoyaltyVaultPlatformFee(_platformFee);
        }

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/9#issuecomment-1099594175):**

> This is an issue and we intend to fix it. The recommended mitigation looks good and will be considered.
> 
> We also agree that this is a med risk as this can currently only be done by the contract owner which is us at Joyn

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/9#issuecomment-1105957959):**

> Instead of having to come up with a “reasonable” `MAX_FEE`, consider instead just preventing the fee from ever being raised, and only allowing it to be lowered.

**[deluca-mike (judge) increased severity to High and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/9#issuecomment-1105964175):**

> While I was originally leaning Medium Risk, after taking the arguments made by the duplicate issues into account, I am now leaning High Risk. The rationale is that, a DOS of `sendToSplitter` via a high `platformFee` not only harms stakeholders of the `RoyaltyVault` that would get the remainder of the balance, split, but may also prevent all NFT transfers if `sendToSplitter` is hooked into as part of all token transfer, via royalty payments. A malicious or disgruntled `RoyaltyVault` owner can hold all the NFTs hostage that call `sendToSplitter` atomically on transfers.
> 
> So there are 2 issues that need to be solved here:
> 
> *   protect NFT holders by ensuring `platformFee` (or any other values) cannot be set to a value that would cause `sendToSplitter` to fail (`splitterShare = 0` or `platformShare > balanceOfVault`), or don’t have `sendToSplitter` be called on NFT transfers
> *   protect royalty split recipients by putting an arbitrary max to the fee, or only allowing the fee to be reduced

* * *

[](#h-06-storage-collision-between-proxy-and-implementation-lack-eip-1967)[\[H-06\] STORAGE COLLISION BETWEEN PROXY AND IMPLEMENTATION (LACK EIP 1967)](https://github.com/code-423n4/2022-03-joyn-findings/issues/108)
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by peritoflores_

Storage collision because of lack of EIP1967 could cause conflicts and override sensible variables

### [](#proof-of-concept-4)Proof of Concept

    contract CoreProxy is Ownable {
           address private immutable _implement;

When you implement proxies, logic and implementation share the same storage layout. In order to avoid storage conflicts EIP1967 was proposed.([https://eips.ethereum.org/EIPS/eip-1967](https://eips.ethereum.org/EIPS/eip-1967)) The idea is to set proxy variables at fixed positions (like `impl` and `admin` ).

For example, according to the standard, the slot for for logic address should be

`0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` (obtained as `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)` ).

In this case, for example, as you inherits from `Ownable` the variable \_owner is at the first slot and can be overwritten in the implementation. There is a table at OZ site that explains this scenario more in detail

[https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies](https://docs.openzeppelin.com/upgrades-plugins/1.x/proxies)

section “Unstructured Storaged Proxies”

### [](#recommended-mitigation-steps-5)Recommended Mitigation Steps

Consider using EIP1967

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/108#issuecomment-1099710973):**

> This is an issue we want to investigate and fix if our investigation suggests we indeed need to make improvement on that end.
> 
> At the same time, I have little idea of what is the impact of this issue. I’m not sure if it’s a high risk item

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/108#issuecomment-1106035099):**

> Impact would be that an upgrade could brick a contract by simply rearranging inheritance order, or adding variables to an inherited contract, since the implantation slot will not be where it is expected. As the warden suggests, its critical that the implementation slot be fixed at an explicit location, and not an implicit location derived purely from inheritance and declaration order.

* * *

[](#h-07-duplicate-nfts-can-be-minted-if-payabletoken-has-a-callback-attached-to-it)[\[H-07\] Duplicate NFTs Can Be Minted if `payableToken` Has a Callback Attached to it](https://github.com/code-423n4/2022-03-joyn-findings/issues/121)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by leastwood_

[https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L139-L167](https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L139-L167)

[https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50-L56](https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50-L56)

### [](#impact-1)Impact

The `mintToken()` function is called to mint unique tokens from an `ERC721` collection. This function will either require users to provide a merkle proof to claim an airdropped token or pay a fee in the form of a `payableToken`. However, because the `payableToken` is paid before a token is minted, it may be possible to reenter the `mintToken()` function if there is a callback attached before or after the token transfer. Because `totalSupply()` has not been updated for the new token, a user is able to bypass the `totalSupply() + amount <= maxSupply` check. As a result, if the user mints the last token, they can reenter and mint duplicate NFTs as the way `tokenId` is generated will wrap around to the start again.

### [](#proof-of-concept-5)Proof of Concept

For the sake of this example, let’s say `startingIndex = 0` and `maxSupply = 100`. `tokenId` is minted according to `((startingIndex + totalSupply()) % maxSupply) + 1`. If we see that a user mints a token where `totalSupply() = maxSupply - 1 = 99` and they reenter the function, then the next token to mint will actually be of index `1` as `totalSupply() % maxSupply = 0`. Calculating the first `tokenId`, we get `((0 + 0) % maxSupply) + 1 = 1` which is a duplicate of our example.

### [](#recommended-mitigation-steps-6)Recommended Mitigation Steps

Consider adding reentrancy protections to prevent users from abusing this behaviour. It may also be useful to follow the checks-effects pattern such that all external/state changing calls are made at the end.

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/121#issuecomment-1099689645):**

> This is an issue we intend to investigate and fix if indeed it is an issue

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/121#issuecomment-1106037774):**

> This is a valid high risk issue. Also, for reference, the checks-effects-interactions (CEI) pattern suggests you, in this order:
> 
> *   perform checks that something can be done
> *   perform the effects (update storage and emit events)
> *   interact with other functions/contracts (since you may not be sure they will call out and re-enter)

* * *

[](#h-08-funds-cannot-be-withdrawn-in-corecollectionwithdraw)[\[H-08\] Funds cannot be withdrawn in `CoreCollection.withdraw`](https://github.com/code-423n4/2022-03-joyn-findings/issues/80)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by ych18, also found by hickuphh3 and WatchPug_

The `CoreCollection.withdraw` function uses `payableToken.transferFrom(address(this), msg.sender, amount)` to transfer tokens from the `CoreCollection` contract to the `msg.sender` ( who is the owner of the contract). The usage of `transferFrom` can result in serious issues. In fact, many ERC20 always require that in `transferFrom` `allowance[from][msg.sender] >= amount`, so in this case the call to the `withdraw` function will revert as the `allowance[CoreCollection][CoreCollection] == 0` and therefore the funds cannot ben withdrawn and will be locked forever in the contract.

### [](#recommendation)Recommendation

Replace `transferFrom` with `transfer`

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/80#issuecomment-1100089878):**

> duplicate of #52

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/80#issuecomment-1153003850):**

> This is not a duplicate, as it pertains to the wrong use of transfer vs transferFrom, which can have implications regarding required allowances.

* * *

[](#h-09-erc20-tokens-with-no-return-value-will-fail-to-transfer)[\[H-09\] ERC20 tokens with no return value will fail to transfer](https://github.com/code-423n4/2022-03-joyn-findings/issues/83)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by ych18, also found by wuwe1_

[https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L43-L46](https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L43-L46)

[https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57](https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57)

### [](#vulnerability-details)Vulnerability details

Although the ERC20 standard suggests that a transfer should return true on success, many tokens are non-compliant in this regard (including high profile, like USDT) . In that case, the .transfer() call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.

### [](#recommendation-1)Recommendation

Consider using OpenZeppelin’s SafeERC20

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/83#issuecomment-1099512222):**

> duplicate of #52

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/83#issuecomment-1153004716):**

> Actually not a duplicate of #52, since it pertains to return data size handling causing an issue, rather than failure to handle a true/false return at all. Still, same solution (use SafeERC20).

* * *

[](#medium-risk-findings-12)Medium Risk Findings (12)
=====================================================

[](#m-01-dos-attacker-may-front-run-createsplit-with-a-merkleroot-causing-future-transactions-with-the-same-merkleroot-to-revert)[\[M-01\] DoS: Attacker May Front-Run `createSplit()` With A `merkleRoot` Causing Future Transactions With The Same `merkleRoot` to Revert](https://github.com/code-423n4/2022-03-joyn-findings/issues/33)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by kirk-baird_

A `merkleRoot` may only be used once in `createSplit()` since it is used as `salt` to the deployment of a `SplitProxy`.

The result is an attacker may front-run any `createSplit()` transaction in the mem pool and create another `createSplit()` transaction with a higher gas price that uses the same `merkleRoot` but changes the other fields such as the `_collectionContract` or `_splitAsset()`. The original transaction will revert and the user will not be able to send any more transaction with this `merkleRoot`.

The user would therefore have to generate a new merkle tree with different address, different allocations or a different order of leaves in the tree to create a new merkle root. However, the attack is repeateable and there is no guarantee this new merkle root will be successfully added to a split without the attacker front-running the transaction again.

### [](#proof-of-concept-6)Proof of Concept

The excerpt from `createSplitProxy()` shows the `merkleRoot()` being used as a `salt`.

      splitProxy = address(
        new SplitProxy{salt: keccak256(abi.encode(merkleRoot))}()
      );

### [](#recommended-mitigation-steps-7)Recommended Mitigation Steps

As seems to be the case here if the transaction address does NOT need to be known ahead of time consider removing the `salt` parameter from the contract deployment.

Otherwise, if the transaction address does need to be known ahead of time then consider concatenating `msg.sender` to the `merkleRoot`. e.g.

    splitProxy = address(
        new SplitProxy{salt: keccak256(abi.encode(msg.sender, merkleRoot))}()
      )

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/33#issuecomment-1099702622):**

> This is an issue and intend to fix it

* * *

[](#m-02-fixed-amount-of-gas-sent-in-call-may-be-insufficient)[\[M-02\] Fixed Amount of Gas Sent in Call May Be Insufficient](https://github.com/code-423n4/2022-03-joyn-findings/issues/8)
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by kirk-baird_

### [](#impact-2)Impact

The function `attemptETHTransfer()` makes a call with a fixed amount of gas, 30,000. If the receiver is a contract this may be insufficient to process the `receive()` function. As a result the user would be unable to receive funds from this function.

### [](#proof-of-concept-7)Proof of Concept

        function attemptETHTransfer(address to, uint256 value)
            private
            returns (bool)
        {
            // Here increase the gas limit a reasonable amount above the default, and try
            // to send ETH to the recipient.
            // NOTE: This might allow the recipient to attempt a limited reentrancy attack.
            (bool success, ) = to.call{value: value, gas: 30000}("");
            return success;
        }

### [](#recommended-mitigation-steps-8)Recommended Mitigation Steps

Consider removing the `gas` field to use the default amount and protect from reentrancy by using reentrancy guards and the [check-effects-interaction pattern](https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html). Note this pattern is already applied correctly.

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/8#issuecomment-1100121921):**

> This is an issue we want to investigate and fix if needed

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/8#issuecomment-1105949579):**

> Consider that changes to the network could result in re-pricing of opcodes which can make:
> 
> *   opcodes less expensive, which would re-introduce the opportunity for re-entrancy that the old costs prevented
> *   opcodes more expensive, which would break this function altogether
> 
> If `attemptETHTransfer` is the only way to extract ETH stored in this contract, then an Ethereum upgrade could result in lost funds. Luckily, as long as [access lists](https://eips.ethereum.org/EIPS/eip-2930) remain in the protocol, a route would exist to recover and/or restore functionality.

* * *

[](#m-03-royaltyvaultsol-is-not-equipped-to-handle-on-chain-royalties-from-secondary-sales)[\[M-03\] `RoyaltyVault.sol` is Not Equipped to Handle On-Chain Royalties From Secondary Sales](https://github.com/code-423n4/2022-03-joyn-findings/issues/130)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by leastwood_

[https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol](https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol)

[https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol](https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol)

### [](#impact-3)Impact

The Joyn documentation mentions that Joyn royalty vaults should be equipped to handle revenue generated on a collection’s primary and secondary sales. Currently, `CoreCollection.sol` allows the collection owner to receive a fee on each token mint, however, there is no existing implementation which allows the owner of a collection to receive fees on secondary sales.

After discussion with the Joyn team, it appears that this will be gathered from Opensea which does not have an on-chain royalty mechanism. As such, each collection will need to be added manually on Opensea, introducing further centralisation risk. It is also possible for users to avoid paying the secondary fee by using other marketplaces such as Foundation.

### [](#recommended-mitigation-steps-9)Recommended Mitigation Steps

Consider implementing the necessary functionality to allow for the collection of fees through an on-chain mechanism. `ERC2981` outlines the appropriate behaviour for this.

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/130#issuecomment-1099679515):**

> This is a great observation. Something we are aware of and intend to fix as well. 👍

* * *

[](#m-04-createproject-can-be-frontrun)[\[M-04\] createProject can be frontrun](https://github.com/code-423n4/2022-03-joyn-findings/issues/26)
----------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by wuwe1, also found by defsec, and kirk-baird_

This is dangerous in scam senario because the malicious user can frontrun and become the owner of the collection. As owner, one can withdraw `paymentToken`. (note that \_collections.isForSale can be change by frontrunner)

### [](#proof-of-concept-8)Proof of Concept

1.  Anyone can call `createProject`.

[https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77](https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreFactory.sol#L70-L77)

      function createProject(
        string memory _projectId,
        Collection[] memory _collections
      ) external onlyAvailableProject(_projectId) {
        require(
          _collections.length > 0,
          'CoreFactory: should have more at least one collection'
        );

### [](#recommended-mitigation-steps-10)Recommended Mitigation Steps

Two ways to mitigate.

1.  Consider use white list on project creation.
2.  Ask user to sign their address and check the signature against `msg.sender`. [https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L102](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/ECDSA.sol#L102)

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/26#issuecomment-1099700412):**

> This is an issue and we intend to fix it!

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/26#issuecomment-1105980217):**

> The solutions listed in #34 and #35 are better.

* * *

[](#m-05-gas-costs-will-likely-result-in-any-fees-sent-to-the-splitter-being-economically-unviable-to-recover)[\[M-05\] Gas costs will likely result in any fees sent to the Splitter being economically unviable to recover.](https://github.com/code-423n4/2022-03-joyn-findings/issues/27)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by TomFrenchBlockchain_

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163)

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307)

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50)

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169)

### [](#impact-4)Impact

Collection owners will likely lose money by claiming fees unless the fees from a single NFT sale outweighs the cost of claiming it (not guaranteed).

### [](#proof-of-concept-9)Proof of Concept

Consider a new `Collection` with a `RoyaltyVault` and `Splitter` set and a nonzero mint fee.

When calling `mintToken`, the `_handlePayment` function is called [https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L161-L163)

This will transfer the minting fee to the `RoyaltyVault` contract.

On each transfer of an NFT within the collection (for instance in the `_mint` call which occurs directly after calling `_handlePayment`), the `Collection` contract will call `sendToSplitter` on the `RoyaltyVault`:

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L307)

This function will forward the collection owners’ portion of the minting on to the `Splitter` contract but another important thing to note is that we call `Splitter.incrementWindow`.

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L50)

This results in the fees newly deposited into the `Splitter` contract being held in a separate “window” to the fees from previous or later mints and need to be claimed separately. Remember that this process happens on every NFT sale so the only funds which will be held in this window will be the minting fees for this particular mint.

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L149-L169)

From this we can see that the `claim` function will only claim the fraction of the fees which are owed to the caller from a single NFT mint.

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L112-L142](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L112-L142)

Note that we can attempt to claim from multiple windows in a single transaction using `claimForAllWindow` but as the name suggests it performs an unbounded loop trying to claim all previous windows (even ones which have already been claimed!) and it is likely that with a new window for every NFT sold this function will exceed the gas limit (consider an 10k token collection resulting in trying to do 10k SSTOREs at 20k gas each.), leaving us to claim each window individually with `claim`.

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L35-L62](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L35-L62)

We’re then forced to claim the royalties from each NFT sold one by one, having to send huge numbers of calls to `claim` incurring the base transaction cost many times over and performing many ERC20 transfers when we could have just performed one.

Compound on this that this needs to be repeated by everyone included in the split, multiplying the costs of claiming.

Medium risk as it’s gas inefficiency to the point of significant value leakage where collection owners will lose a large fraction of their royalties.

### [](#recommended-mitigation-steps-11)Recommended Mitigation Steps

It doesn’t seem like the “window” mechanism does anything except raise gas costs to the extent that it will be very difficult to withdraw fees so it should be removed.

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/27#issuecomment-1099551627):**

> This is a very fair point and we’ll consider fixing this issue.

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/27#issuecomment-1105984197):**

> Aside from the very valid points made by the warden, it seems that the heavy functions called from the `_beforeTokenTransfer` also create a lot of friction for the NFT owners. Might make more sense to have royalty splitting happen asynchronously from NFT transfers (i.e. let the cost of splitting be the burden of royalty stakeholders, not NFT holders).
> 
> If NFT transferring becomes too costly, someone could make a “de-joyn” contract which can “re-tokenize” NFTs sent to it, so that they can be transferred without having to worry about `_beforeTokenTransfer` (or royalties, for that matter).
> 
> See Recommended Mitigation Steps in #37 for more info.

* * *

[](#m-06-corecollections-token-transfer-can-be-disabled)[\[M-06\] CoreCollection’s token transfer can be disabled](https://github.com/code-423n4/2022-03-joyn-findings/issues/37)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by hyh, also found by robee_

[https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57](https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57)

[https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164](https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164)

### [](#impact-5)Impact

When royaltyAsset is an ERC20 that doesn’t allow zero amount transfers, the following griefing attack is possible, entirely disabling CoreCollection token transfer by precision degradation as both reward distribution and vault balance can be manipulated.

Suppose splitterProxy is set, all addresses and fees are configured correctly, system is in normal operating state.

POC:

Bob the attacker setup a bot which every time it observes positive royaltyVault balance:

1.  runs `sendToSplitter()`, distributing the whole current royaltyAsset balance of the vault to splitter and platform, so vault balance becomes zero
2.  sends `1 wei` of royaltyAsset to the royaltyVault balance
3.  each next CoreCollection token transfer will calculate `platformShare = (balanceOfVault * platformFee) / 10000`, which will be 0 as platformFee is supposed to be less than 100%, and then there will be an attempt to transfer it to `platformFeeRecipient`

If royaltyAsset reverts on zero amount transfers, the whole operation will fail as the success of `IERC20(royaltyAsset).transfer(platformFeeRecipient, platformShare)` is required for each CoreCollection token transfer, which invokes `sendToSplitter()` in `_beforeTokenTransfer()` as vault balance is positive in (3).

Notice, that Bob needn’t to front run the transfer, it is enough to empty the balance in a lazy way, so cumulative gas cost of the attack can be kept moderate.

Setting severity to medium as on one hand, the attack is easy to setup and completely blocks token transfers, making the system inoperable, and it looks like system has to be redeployed on such type of attack with some manual management of user funds, which means additional operational costs and reputational damage. On the another, it is limited to the zero amount reverting royaltyAsset case or the case when platformFee is set to 100%.

That is, as an another corner case, if platformFee is set to 100%, `platformShare` will be `1 wei` and `splitterShare` be zero in (3), so this attack be valid for any royaltyAsset as it is required in Splitter’s `incrementWindow` that `splitterShare` be positive.

### [](#proof-of-concept-10)Proof of Concept

As royaltyAsset can be an arbitrary ERC20 it can be reverting on zero value transfers:

[https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers](https://github.com/d-xo/weird-erc20#revert-on-zero-value-transfers)

`_beforeTokenTransfer` runs `IRoyaltyVault(royaltyVault).sendToSplitter()` whenever royaltyVault is set and have positive balance:

[https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L307](https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L307)

`sendToSplitter()` leaves vault balance as exactly zero as `splitterShare = balanceOfVault - platformShare`, i.e. no dust is left behind:

[https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L41](https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L41)

This way the balance opens up for the tiny amount manipulation.

One require that can fail the whole operation is `platformShare` transfer:

[https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57](https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L51-L57)

Another is positive `royaltyAmount` = `splitterShare` requirement:

[https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164](https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L164)

### [](#recommended-mitigation-steps-12)Recommended Mitigation Steps

The issue is that token transfer, which is core system operation, require fee splitting to be done on the spot. More failsafe design is to try to send the fees and record the amounts not yet distributed, not requiring immediate success. The logic here is that transfer itself is more important than fee distribution, which is simple enough and can be performed in a variety of ways later.

Another issue is a combination of direct balance usage and the lack of access controls of the sendToSplitter function, but it only affects fee splitting and is somewhat harder to address.

As one approach consider trying, but not requiring `IRoyaltyVault(royaltyVault).sendToSplitter()` to run successfully as it can be executed later with the same result.

Another, a simpler one (the same is in `Griefing attack is possible making Splitter's claimForAllWindows inaccessible` issue), is to introduce action threshold, `MIN_ROYALTY_AMOUNT`, to `sendToSplitter()`, for example:

Now:

    /**
     * @dev Send accumulated royalty to splitter.
     */
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();
    
        require(
            balanceOfVault > 0,
            "Vault does not have enough royalty Asset to send"
        );
    	...
    
        emit RoyaltySentToSplitter(...);
        emit FeeSentToPlatform(...);
    }

To be:

    /**
     * @dev Send accumulated royalty to splitter if it's above MIN_ROYALTY_AMOUNT threshold.
     */
    function sendToSplitter() external override {
        uint256 balanceOfVault = getVaultBalance();
    
        if (balanceOfVault > MIN_ROYALTY_AMOUNT) {
    		...
    
    	    emit RoyaltySentToSplitter(...);
    	    emit FeeSentToPlatform(...);
        }
    }

**[sofianeOuafir (Joyn) confirmed](https://github.com/code-423n4/2022-03-joyn-findings/issues/37)**

* * *

[](#m-07-ineffective-handling-of-fot-or-rebasing-tokens)[\[M-07\] Ineffective Handling of FoT or Rebasing Tokens](https://github.com/code-423n4/2022-03-joyn-findings/issues/43)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by kirk-baird, also found by defsec, hickuphh3, and leastwood_

Certain ERC20 tokens may change user’s balances over time (positively or negatively) or charge a fee when a transfer is called (FoT tokens). The accounting of these tokens is not handled by `RoyaltyVault.sol` or `Splitter.sol` and may result in tokens being stuck in `Splitter` or overstating the balance of a user

Thus, for FoT tokens if all users tried to claim from the Splitter there would be insufficient funds and the last user could not withdraw their tokens.

### [](#proof-of-concept-11)Proof of Concept

The function `RoyaltyVault.sendToSplitter()` will transfer `splitterShare` tokens to the `Splitter` and then call `incrementWindow(splitterShare)` which tells the contract to split `splitterShare` between each of the users.

            require(
                IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
                "Failed to transfer royalty Asset to splitter"
            );
            require(
                ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
                "Failed to increment splitter window"
            );

Since the `Splitter` may receive less than `splitterShare` tokens if there is a fee on transfer the `Splitter` will overstate the amount split and each user can claim more than their value (except the last user who claims nothing as the contract will have insufficient funds to transfer them the full amount).

Furthermore, if the token rebase their value of the tokens down while they are sitting in the `Splitter` the same issue will occur. If the tokens rebase their value up then this will not be accounted for in the protocol.

### [](#recommended-mitigation-steps-13)Recommended Mitigation Steps

It is recommend documenting clearly that rebasing token should not be used in the protocol.

Alternatively, if it is a requirement to handle rebasing tokens balance checks should be done before and after the transfer to ensure accurate accounting. Note: this makes the contract vulnerable to reentrancy and so a [reentrancy guard](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol) must be placed over the function `sendToSplitter()`.

            uint256 balanceBefore = IERC20(royaltyAsset).balanceOf(splitterProxy);
            require(
                IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
                "Failed to transfer royalty Asset to splitter"
            );
            uint256 balanceAfter = IERC20(royaltyAsset).balanceOf(splitterProxy);
            require(
                ISplitter(splitterProxy).incrementWindow(balanceAfter - balanceBefore) == true,
                "Failed to increment splitter window"
            );

**[sofianeOuafir (Joyn) confirmed](https://github.com/code-423n4/2022-03-joyn-findings/issues/43)**

* * *

[](#m-08-corecollection-starting-index-is-pseudo-randomly-generated-allowing-for-gameable-nft-launches)[\[M-08\] CoreCollection: Starting index is pseudo-randomly generated, allowing for gameable NFT launches](https://github.com/code-423n4/2022-03-joyn-findings/issues/50)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by hickuphh3_

In Paradigm’s article _[“A Guide to Designing Effective NFT Launches”](https://www.paradigm.xyz/2021/10/a-guide-to-designing-effective-nft-launches),_ one of the desirable properties of an NFT launch is **unexploitable fairness:** Launches _must_ have true randomness to ensure that predatory users cannot snipe the rarest items at the expense of less sophisticated users.

It is therefore highly recommended to find a good source of entropy for the generation of the starting index. The `block.number` isn’t random at all; it only incrementally increases, allowing anyone to easily compute the starting indexes of the next 10,000 blocks for instance.

    contract FortuneTeller {
      function predictStartingIndexes(uint256 maxSupply, uint256 numBlocks) 
        external
        view
        returns 
        (uint256[] memory startingIndexes) {
        startingIndexes = new uint[](numBlocks);
        for (uint256 i = 0; i < numBlocks; ++i) {
            startingIndexes[i] = (uint256(
                keccak256(abi.encodePacked("CoreCollection", block.number + i))
            ) % maxSupply) +
            1;
        }
      }
    }

Coupled with the fact that the `_baseUri` is set upon initialization, the metadata could be scrapped beforehand to determine the rare NFTs.

Thus, NFT mints can be gamed / exploited.

### [](#recommended-mitigation-steps-14)Recommended Mitigation Steps

Consider exploring the use of commit-reveal schemes (eg. blockhash of a future block, less gameable but not foolproof) or VRFs.

**[sofianeOuafir (Joyn) acknowledged and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/50#issuecomment-1100122798):**

> This is a known issue and for now, we’re not going to solve it

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/50#issuecomment-1106006297):**

> I’d reconsider not completely it, but rather doing `keccak256(abi.encodePacked("CoreCollection", blockhash(block.number - 1), block.coinbase, msg.sender, i))` so at least there is a much smaller set of users that will know what the previous blockhash and the current miner will be by the time the tx mines, and it will be salted with the sender.
> 
> It’s not perfect, but it’s significantly better.

* * *

[](#m-09-differing-percentage-denominators-causes-confusion-and-potentially-brick-claims)[\[M-09\] Differing percentage denominators causes confusion and potentially brick claims](https://github.com/code-423n4/2022-03-joyn-findings/issues/53)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by hickuphh3, also found by 0x_

[https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L14](https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L14)

[https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L103](https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/Splitter.sol#L103)

### [](#details--impact)Details & Impact

There is a `PERCENTAGE_SCALE = 10e5` defined, but the actual denominator used is `10000`. This is aggravated by the following factors:

1.  Split contracts are created by collection owners, not the factory owner. Hence, there is a likelihood for someone to mistakenly use `PERCENTAGE_SCALE` instead of `10000`.
2.  The merkle root for split distribution can only be set once, and a collection’s split and royalty vault can’t be changed once created.

Thus, if an incorrect denominator is used, the calculated claimable amount could exceed the actual available funds in the contract, causing claims to fail and funds to be permanently locked.

### [](#recommended-mitigation-steps-15)Recommended Mitigation Steps

Remove `PERCENTAGE_SCALE` because it is unused, or replace its value with `10_000` and use that instead.

P.S: there is an issue with the example scaled percentage given for platform fees `(5% = 200)`. Should be `500` instead of `200`.

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/53#issuecomment-1100123940):**

> This is an issue and we intend to fix it

* * *

[](#m-10-add-a-timelock-to-setplatformfee)[\[M-10\] Add a timelock to `setPlatformFee()`](https://github.com/code-423n4/2022-03-joyn-findings/issues/112)
---------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by Dravee_

[https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/SplitFactory.sol#L120](https://github.com/code-423n4/2022-03-joyn/blob/main/splits/contracts/SplitFactory.sol#L120)

[https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L67](https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L67)

### [](#impact-6)Impact

It is a good practice to give time for users to react and adjust to critical changes. A timelock provides more guarantees and reduces the level of trust required, thus decreasing risk for users. It also indicates that the project is legitimate.

Here, no timelock capabilities seem to be used

I believe this impacts multiple users enough to make them want to react / be notified ahead of time.

### [](#recommended-mitigation-steps-16)Recommended Mitigation Steps

Consider adding a timelock to `setPlatformFee()`

**[sofianeOuafir (Joyn) acknowledged and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/112#issuecomment-1099708757):**

> This is a good idea. We will consider mitigating this but at the same time it might not be something we will solve

* * *

[](#m-11-not-handling-return-value-of-transferfrom-command-can-create-inconsistency)[\[M-11\] Not handling return value of transferFrom command can create inconsistency](https://github.com/code-423n4/2022-03-joyn-findings/issues/81)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by hubble_

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L175-L176](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L175-L176)

[https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L54-L55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L54-L55)

### [](#vulnerability-details-1)Vulnerability details

The below transferFrom command is called at two places in the core contracts, followed by an emit event

    payableToken.transferFrom(msg.sender,recipient,_amount)
    emit ...(...);

The return value is not checked during the payableToken.transferFrom

### [](#impact-7)Impact

In the event of failure of payableToken.transferFrom(…), the emit event is still generated causing the downstream applications to capture wrong transaction / state of the protocol.

### [](#proof-of-concept-12)Proof of Concept

1.  Contract CoreCollection.sol  
    function withdraw()
2.  Contract ERC721Payable.sol function \_handlePayment

### [](#recommended-mitigation-steps-17)Recommended Mitigation Steps

Add a require statement as being used in the RoyaltyVault.sol

    require( payableToken.transferFrom(msg.sender,recipient,_amount) == true,
                "Failed to transfer amount to recipient" );

**[sofianeOuafir (Joyn) confirmed, disagreed with severity and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/81#issuecomment-1099290275):**

> In my opinion, the severity level should be 3 (High Risk) instead of 2 (Med Risk) duplicate of #52

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/81#issuecomment-1153003465):**

> No longer a duplicate because this issue pertains specifically to the false emission of events when an underlying call would have failed.

* * *

[](#m-12-corecollectionsetroyaltyvault-doesnt-check-royaltyvaultroyaltyasset-against-payabletoken-resulting-in-potential-permanent-lock-of-payabletokens-in-royaltyvault)[\[M-12\] `CoreCollection.setRoyaltyVault` doesn’t check `royaltyVault.royaltyAsset` against `payableToken`, resulting in potential permanent lock of `payableTokens` in royaltyVault](https://github.com/code-423n4/2022-03-joyn-findings/issues/73)
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

_Submitted by rayn_

[https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L185](https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/CoreCollection.sol#L185)

[https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50](https://github.com/code-423n4/2022-03-joyn/blob/main/core-contracts/contracts/ERC721Payable.sol#L50)

[https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L31](https://github.com/code-423n4/2022-03-joyn/blob/main/royalty-vault/contracts/RoyaltyVault.sol#L31)

### [](#impact-8)Impact

Each CoreProxy is allowed to be associated with a RoyaltyVault, the latter which would be responsible for collecting minting fees and distributing to beneficiaries. Potential mismatch between token used in CoreProxy and RoyaltyVault might result in minting tokens being permanently stuck in RoyaltyVault.

### [](#proof-of-concept-13)Proof of Concept

Each RoyaltyVault can only handle the `royaltyVault.royaltyAsset` token assigned upon creation, if any other kind of tokens are sent to the vault, it would get stuck inside the vault forever.

        function sendToSplitter() external override {
            ...
            require(
                IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
                "Failed to transfer royalty Asset to splitter"
            );
            ...
            require(
                IERC20(royaltyAsset).transfer(
                    platformFeeRecipient,
                    platformShare
                ) == true,
                "Failed to transfer royalty Asset to platform fee recipient"
            );
            ...
        }

Considering that pairing of CoreProxy and RoyaltyVault is not necessarily handled automatically, and can sometimes be manually assigned, and further combined with the fact that once assigned, CoreProxy does not allow modifications of the pairing RoyaltyVault. We can easily conclude that if a CoreProxy is paired with an incompatible RoyaltyVault, the `payableToken` minting fees automatically transferred to RoyaltyVault by `_handlePayment` will get permanently stuck.

         function setRoyaltyVault(address _royaltyVault)
             external
             onlyVaultUninitialized
         {
             ...
             royaltyVault = _royaltyVault;
             ...
         }
    
         function _handlePayment(uint256 _amount) internal {
             address recipient = royaltyVaultInitialized()
                 ? royaltyVault
                 : address(this);
             payableToken.transferFrom(msg.sender, recipient, _amount);
             ...
         }

### [](#tools-used)Tools Used

vim, ganache-cli

### [](#recommended-mitigation-steps-18)Recommended Mitigation Steps

While assigning vaults to CoreProxy, check if `payableToken` is the same as `royaltyVault.royaltyAsset`

         function setRoyaltyVault(address _royaltyVault)
             external
             onlyVaultUninitialized
         {
             require(
                 payableToken == _royaltyVault.royaltyAsset(),
                 "CoreCollection : payableToken must be same as royaltyAsset."
             );
             ...
             royaltyVault = _royaltyVault;
             ...
         }

**[sofianeOuafir (Joyn) confirmed](https://github.com/code-423n4/2022-03-joyn-findings/issues/73)**

**[deluca-mike (judge) decreased severity to Medium and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/73#issuecomment-1153010132):**

> Downgraded to medium because, while a more automated and validated way of assigning a compatible royalty vault would prevent this issue, in the current framework you’d need to make a user error (albeit one that is not easy to spot), to lose funds.

* * *

[](#low-risk-and-non-critical-issues)Low Risk and Non-Critical Issues
=====================================================================

For this contest, 25 reports were submitted by wardens detailing low risk and non-critical issues. The [report highlighted below](https://github.com/code-423n4/2022-03-joyn-findings/issues/131) by **CertoraInc** received the top score from the judge.

_The following wardens also submitted reports: [robee](https://github.com/code-423n4/2022-03-joyn-findings/issues/15), [rayn](https://github.com/code-423n4/2022-03-joyn-findings/issues/76), [defsec](https://github.com/code-423n4/2022-03-joyn-findings/issues/96), [hyh](https://github.com/code-423n4/2022-03-joyn-findings/issues/38), [BouSalman](https://github.com/code-423n4/2022-03-joyn-findings/issues/32), [IllIllI](https://github.com/code-423n4/2022-03-joyn-findings/issues/57), [0xDjango](https://github.com/code-423n4/2022-03-joyn-findings/issues/30), [kenta](https://github.com/code-423n4/2022-03-joyn-findings/issues/124), [hubble](https://github.com/code-423n4/2022-03-joyn-findings/issues/89), [Dravee](https://github.com/code-423n4/2022-03-joyn-findings/issues/110), [z3s](https://github.com/code-423n4/2022-03-joyn-findings/issues/71), [saian](https://github.com/code-423n4/2022-03-joyn-findings/issues/63), [Hawkeye](https://github.com/code-423n4/2022-03-joyn-findings/issues/88), [kirk-baird](https://github.com/code-423n4/2022-03-joyn-findings/issues/47), [0v3rf10w](https://github.com/code-423n4/2022-03-joyn-findings/issues/40), [wuwe1](https://github.com/code-423n4/2022-03-joyn-findings/issues/103), [hake](https://github.com/code-423n4/2022-03-joyn-findings/issues/97), [0x](https://github.com/code-423n4/2022-03-joyn-findings/issues/106), [Ruhum](https://github.com/code-423n4/2022-03-joyn-findings/issues/25), [0x1f8b](https://github.com/code-423n4/2022-03-joyn-findings/issues/59), [leastwood](https://github.com/code-423n4/2022-03-joyn-findings/issues/128), [ych18](https://github.com/code-423n4/2022-03-joyn-findings/issues/86), [WatchPug](https://github.com/code-423n4/2022-03-joyn-findings/issues/66), and [0xkatana](https://github.com/code-423n4/2022-03-joyn-findings/issues/45)._

1.  Different pragma versions - the core-contracts use `pragma solidity ^0.8.0` and the rest of the contracts use `pragma solidity ^0.8.4`
2.  Use a specific solidity version instead of using `^`, to prevent future solidity versions impacting your code and creating issues.
3.  In the comments and variable names you wrote ETH instead of wETH, which is un-correct (that’s an ERC20 so it must be wETH) `sol function transferSplitAsset(address to, uint256 value) private returns (bool didSucceed) { // Try to transfer ETH to the given recipient. didSucceed = IERC20(splitAsset).transfer(to, value); require(didSucceed, "Failed to transfer ETH"); emit TransferETH(to, value, didSucceed); }`
4.  In the comment before the function, you wrote returns instead of the known `@return` tag `sol /** * @notice Mint token * @dev A starting index is calculated at the time of first mint * returns a tokenId * @param _to Token recipient */ function mint(address _to) private returns (uint256 tokenId) { if (startingIndex == 0) { setStartingIndex(); } tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1; _mint(_to, tokenId); }`
5.  Low level calls (call, delegate call and static call) return success if the called contract doesn’t exist (not deployed or destructed). This can be seen here [https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf](https://github.com/Uniswap/v3-core/blob/main/audits/tob/audit.pdf) (report #9) and here [https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions](https://docs.soliditylang.org/en/develop/control-structures.html#error-handling-assert-require-revert-and-exceptions).
    
        That means that in `attemptETHTransfer`, if `to` doesn't exist the call will fail but success will be set to true, which will act like the call was successful.
        ```sol
        function attemptETHTransfer(address to, uint256 value)
            private
            returns (bool)
            {
                // Here increase the gas limit a reasonable amount above the default, and try
                // to send ETH to the recipient.
                // NOTE: This might allow the recipient to attempt a limited reentrancy attack.
                (bool success, ) = to.call{value: value, gas: 30000}("");
                return success;
            }
        ```
    
6.  Add `onlyUnInitialized` modifier to the `initialize` function, otherwise the owner can initialize the contract more than one time
7.  `HASHED_PROOF` - upper case variable name that is not constant
8.  If `startingIndex + totalSupply()` will reach `type(uint256).max` the system will be in a stuck state, that’s because the calculation in the \_mint function will overflow
9.  Contracts not declaring that they implement their interfaces - for example `CoreCollection` and `CoreFactory` don’t declare that they implement `ICoreCollection` and `ICoreFactory`
10.  `ICoreFactory` is imported but not used in `CoreProxy`
11.  Didn’t check that the address of the given vault is not zero in the `setPlatformFee` function
12.  Wrong comment in `RoyaltyVaultFactory` and `SplitFactory` \`sol /\*\* \* @dev Set Platform fee for collection contract. \* @param _platformFee Platform fee in scaled percentage. (5% = 200) \* @param \_vault vault address. \*/ function setPlatformFee(address \_vault, uint256 \_platformFee) external { IRoyaltyVault(_vault).setPlatformFee(\_platformFee); }
    
        /**
        * @dev Set Platform fee recipient for collection contract.
        * @param _vault vault address.
        * @param _platformFeeRecipient Platform fee recipient.
        */
        function setPlatformFeeRecipient(
            address _vault,
            address _platformFeeRecipient
        ) external {
            require(_vault != address(0), "Invalid vault");
            require(
                _platformFeeRecipient != address(0),
                "Invalid platform fee recipient"
            );
            IRoyaltyVault(_vault).setPlatformFeeRecipient(_platformFeeRecipient);
        }
        ``` 
    
    **[sofianeOuafir (Joyn) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/131#issuecomment-1100201786):**
    
    > high quality report
    

**[deluca-mike (judge) commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/131#issuecomment-1105952742):**

> add onlyUnInitialized modifier to the initialize function, otherwise the owner can initialize the contract more than one time

* * *

[](#gas-optimizations)Gas Optimizations
=======================================

For this contest, 21 reports were submitted by wardens detailing gas optimizations. The [report highlighted below](https://github.com/code-423n4/2022-03-joyn-findings/issues/56) by **IllIllI** received the top score from the judge.

_The following wardens also submitted reports: [saian](https://github.com/code-423n4/2022-03-joyn-findings/issues/62), [rfa](https://github.com/code-423n4/2022-03-joyn-findings/issues/113), [Dravee](https://github.com/code-423n4/2022-03-joyn-findings/issues/2), [robee](https://github.com/code-423n4/2022-03-joyn-findings/issues/12), [0xkatana](https://github.com/code-423n4/2022-03-joyn-findings/issues/44), [kenta](https://github.com/code-423n4/2022-03-joyn-findings/issues/125), [WatchPug](https://github.com/code-423n4/2022-03-joyn-findings/issues/69), [defsec](https://github.com/code-423n4/2022-03-joyn-findings/issues/92), [Tomio](https://github.com/code-423n4/2022-03-joyn-findings/issues/99), [z3s](https://github.com/code-423n4/2022-03-joyn-findings/issues/70), [Funen](https://github.com/code-423n4/2022-03-joyn-findings/issues/119), [0x1f8b](https://github.com/code-423n4/2022-03-joyn-findings/issues/58), [0v3rf10w](https://github.com/code-423n4/2022-03-joyn-findings/issues/39), [minhquanym](https://github.com/code-423n4/2022-03-joyn-findings/issues/91), [hake](https://github.com/code-423n4/2022-03-joyn-findings/issues/98), [ych18](https://github.com/code-423n4/2022-03-joyn-findings/issues/87), [securerodd](https://github.com/code-423n4/2022-03-joyn-findings/issues/94), [rayn](https://github.com/code-423n4/2022-03-joyn-findings/issues/77), [blackswordsman](https://github.com/code-423n4/2022-03-joyn-findings/issues/120), and [0xNazgul](https://github.com/code-423n4/2022-03-joyn-findings/issues/95)._

[](#g-01-requirerevert-strings-longer-than-32-bytes-cost-extra-gas)\[G-01\] `require()`/`revert()` strings longer than 32 bytes cost extra gas
----------------------------------------------------------------------------------------------------------------------------------------------

1.  File: core-contracts/contracts/ERC721Payable.sol (lines [21-24](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L21-L24))

        require(
          !royaltyVaultInitialized(),
          'CoreCollection: Royalty Vault already initialized'
        );

2.  File: core-contracts/contracts/ERC721Payable.sol (lines [29-32](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L29-L32))

        require(
          royaltyVaultInitialized(),
          'CoreCollection: Royalty Vault not initialized'
        );

3.  File: core-contracts/contracts/ERC721Claimable.sol (line [23](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L23))

        require(!claimableSet(), 'ERC721Claimable: Claimable is already set');

4.  File: core-contracts/contracts/CoreCollection.sol (line [47](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L47))

            require(!initialized, "CoreCollection: Already initialized");

5.  File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55))

            require(
                _maxSupply > 0,
                "CoreCollection: Max supply should be greater than 0"
            );

6.  File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146))

            require(amount > 0, "CoreCollection: Amount should be greater than 0");

7.  File: core-contracts/contracts/CoreCollection.sol (lines [189-192](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L189-L192))

            require(
                msg.sender == splitFactory || msg.sender == owner(),
                "CoreCollection: Only Split Factory or owner can initialize vault."
            );

8.  File: core-contracts/contracts/CoreCollection.sol (lines [204-207](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L204-L207))

            require(
                bytes(HASHED_PROOF).length == 0,
                "CoreCollection: Hashed Proof is set"
            );

9.  File: core-contracts/contracts/CoreCollection.sol (lines [220-223](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L220-L223))

            require(
                startingIndex == 0,
                "CoreCollection: Starting index is already set"
            );

10.  File: core-contracts/contracts/CoreFactory.sol (lines [35-38](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L35-L38))

        require(
          projects[_projectId].creator == address(0),
          'CoreFactory: Unavailable project id'
        );

11.  File: core-contracts/contracts/CoreFactory.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L43-L46))

        require(
          projects[_projectId].creator == msg.sender,
          'CoreFactory: Not an owner of the project'
        );

12.  File: core-contracts/contracts/CoreFactory.sol (lines [51-54](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L51-L54))

        require(
          collections[_collectionId] == address(0),
          'CoreFactory: Unavailable collection id'
        );

13.  File: core-contracts/contracts/CoreFactory.sol (lines [74-77](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L74-L77))

        require(
          _collections.length > 0,
          'CoreFactory: should have more at least one collection'
        );

14.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37))

            require(
                balanceOfVault > 0,
                "Vault does not have enough royalty Asset to send"
            );

15.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [43-46](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L43-L46))

            require(
                IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,
                "Failed to transfer royalty Asset to splitter"
            );

16.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [47-50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L47-L50))

            require(
                ISplitter(splitterProxy).incrementWindow(splitterShare) == true,
                "Failed to increment splitter window"
            );

17.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [51-57](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L51-L57))

            require(
                IERC20(royaltyAsset).transfer(
                    platformFeeRecipient,
                    platformShare
                ) == true,
                "Failed to transfer royalty Asset to platform fee recipient"
            );

18.  File: splits/contracts/SplitFactory.sol (lines [48-51](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L48-L51))

        require(
          splits[_splitId] == address(0),
          'SplitFactory : Split ID already in use'
        );

19.  File: splits/contracts/SplitFactory.sol (lines [81-84](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L81-L84))

        require(
          ICoreCollection(_collectionContract).owner() == msg.sender,
          'Transaction sender is not collection owner'
        );

20.  File: splits/contracts/Splitter.sol (lines [118-121](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L118-L121))

            require(
                !isClaimed(msg.sender, window),
                "NFT has already claimed the given window"
            );

[](#g-02-use-a-more-recent-version-of-solidity)\[G-02\] Use a more recent version of solidity
---------------------------------------------------------------------------------------------

Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value

1.  File: royalty-vault/contracts/RoyaltyVault.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L2))

    pragma solidity ^0.8.4;

2.  File: royalty-vault/contracts/ProxyVault.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L2))

    pragma solidity ^0.8.4;

3.  File: splits/contracts/SplitFactory.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L2))

    pragma solidity ^0.8.4;

4.  File: splits/contracts/SplitProxy.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitProxy.sol#L2))

    pragma solidity ^0.8.4;

5.  File: splits/contracts/Splitter.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L2))

    pragma solidity ^0.8.4;

[](#g-03-use-a-more-recent-version-of-solidity)\[G-03\] Use a more recent version of solidity
---------------------------------------------------------------------------------------------

Use a solidity version of at least 0.8.2 to get compiler automatic inlining Use a solidity version of at least 0.8.3 to get better struct packing and cheaper multiple storage reads Use a solidity version of at least 0.8.4 to get custom errors, which are cheaper at deployment than `revert()/require()` strings Use a solidity version of at least 0.8.10 to have external calls skip contract existence checks if the external call has a return value

1.  File: core-contracts/contracts/ERC721Payable.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L2))

    pragma solidity ^0.8.0;

2.  File: core-contracts/contracts/CoreProxy.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreProxy.sol#L2))

    pragma solidity ^0.8.0;

3.  File: core-contracts/contracts/ERC721Claimable.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Claimable.sol#L2))

    pragma solidity ^0.8.0;

4.  File: core-contracts/contracts/CoreCollection.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L2))

    pragma solidity ^0.8.0;

5.  File: core-contracts/contracts/CoreFactory.sol (line [2](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L2))

    pragma solidity ^0.8.0;

[](#g-04-using-bools-for-storage-incurs-overhead)\[G-04\] Using `bool`s for storage incurs overhead
---------------------------------------------------------------------------------------------------

        // Booleans are more expensive than uint256 or any type that takes up a full
        // word because each write operation emits an extra SLOAD to first read the
        // slot's contents, replace the bits taken up by the boolean, and then write
        // back. This is the compiler's defense against contract upgrades and
        // pointer aliasing, and it cannot be disabled.

[https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/58f635312aa21f947cae5f8578638a85aa2519f5/contracts/security/ReentrancyGuard.sol#L23-L27)

1.  File: core-contracts/contracts/ERC721Payable.sol (line [8](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/ERC721Payable.sol#L8))

      bool public isForSale;

2.  File: core-contracts/contracts/CoreCollection.sol (line [20](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L20))

        bool public initialized;

[](#g-05-using--0-costs-more-gas-than--0-when-used-on-a-uint-in-a-require-statement)\[G-05\] Using `> 0` costs more gas than `!= 0` when used on a `uint` in a `require()` statement
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  File: core-contracts/contracts/CoreCollection.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L52-L55))

            require(
                _maxSupply > 0,
                "CoreCollection: Max supply should be greater than 0"
            );

2.  File: core-contracts/contracts/CoreCollection.sol (line [146](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L146))

            require(amount > 0, "CoreCollection: Amount should be greater than 0");

3.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [34-37](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L34-L37))

            require(
                balanceOfVault > 0,
                "Vault does not have enough royalty Asset to send"
            );

4.  File: splits/contracts/Splitter.sol (line [164](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L164))

            require(royaltyAmount > 0, "No additional funds for window");

[](#g-06-arraylength-should-not-be-looked-up-in-every-loop-of-a-for-loop)\[G-06\] `<array>.length` should not be looked up in every loop of a `for`\-loop
---------------------------------------------------------------------------------------------------------------------------------------------------------

Even memory arrays incur the overhead of bit tests and bit shifts to calculate the array length

1.  File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79))

        for (uint256 i; i < _collections.length; i++) {

2.  File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274))

            for (uint256 i = 0; i < proof.length; i++) {

[](#g-07-it-costs-more-gas-to-initialize-variables-to-zero-than-to-let-the-default-of-zero-be-applied)\[G-07\] It costs more gas to initialize variables to zero than to let the default of zero be applied
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279))

            for (uint256 i = 0; i < _amount; i++) {

2.  File: splits/contracts/Splitter.sol (line [49](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L49))

            uint256 amount = 0;

3.  File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50))

            for (uint256 i = 0; i < currentWindow; i++) {

4.  File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274))

            for (uint256 i = 0; i < proof.length; i++) {

[](#g-08-state-variables-should-be-cached-in-stack-variables-rather-than-re-reading-them-from-storage)\[G-08\] State variables should be cached in stack variables rather than re-reading them from storage
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

The instances below point to the second access of a state variable within a function. Less obvious optimizations include having local storage variables of mappings within state variable mappings or mappings within state variable structs, having local storage variables of structs within mappings, or having local caches of state variable contracts/addresses.

1.  File: core-contracts/contracts/CoreCollection.sol (line [231](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L231))

            emit StartingIndexSet(startingIndex);

2.  File: core-contracts/contracts/CoreCollection.sol (line [264](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L264))

            tokenId = ((startingIndex + totalSupply()) % maxSupply) + 1;

3.  File: splits/contracts/SplitFactory.sol (line [161](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L161))

        delete merkleRoot;

4.  File: splits/contracts/SplitFactory.sol (line [171](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L171))

        delete splitterProxy;

[](#g-09-using-calldata-instead-of-memory-for-read-only-arguments-in-external-functions-saves-gas)\[G-09\] Using `calldata` instead of `memory` for read-only arguments in `external` functions saves gas
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  File: core-contracts/contracts/CoreCollection.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L79))

            string memory _collectionName,

2.  File: core-contracts/contracts/CoreCollection.sol (line [80](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L80))

            string memory _collectionSymbol,

3.  File: core-contracts/contracts/CoreCollection.sol (line [81](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L81))

            string memory _collectionURI,

4.  File: core-contracts/contracts/CoreCollection.sol (line [122](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L122))

            string memory _collectionName,

5.  File: core-contracts/contracts/CoreCollection.sol (line [123](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L123))

            string memory _collectionSymbol

6.  File: core-contracts/contracts/CoreFactory.sol (line [71](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L71))

        string memory _projectId,

7.  File: core-contracts/contracts/CoreFactory.sol (line [72](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L72))

        Collection[] memory _collections

8.  File: core-contracts/contracts/CoreFactory.sol (line [109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L109))

        string memory _projectId,

9.  File: core-contracts/contracts/CoreFactory.sol (line [110](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L110))

        Collection memory _collection

10.  File: core-contracts/contracts/CoreFactory.sol (line [128](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L128))

      function getProject(string memory _projectId)

11.  File: splits/contracts/SplitFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L79))

        string memory _splitId

12.  File: splits/contracts/SplitFactory.sol (line [105](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L105))

        string memory _splitId

[](#g-10-ii-should-be-uncheckediuncheckedi-when-it-is-not-possible-for-them-to-overflow-as-is-the-case-when-used-in-for--and-while-loops)\[G-10\] `++i`/`i++` should be `unchecked{++i}`/`unchecked{++i}` when it is not possible for them to overflow, as is the case when used in `for`\- and `while`\-loops
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279))

            for (uint256 i = 0; i < _amount; i++) {

2.  File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79))

        for (uint256 i; i < _collections.length; i++) {

3.  File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50))

            for (uint256 i = 0; i < currentWindow; i++) {

4.  File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274))

            for (uint256 i = 0; i < proof.length; i++) {

[](#g-11-i-costs-less-gas-than-i-especially-when-its-used-in-for-loops---ii---too)\[G-11\] `++i` costs less gas than `++i`, especially when it’s used in `for`\-loops (`--i`/`i--` too)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  File: core-contracts/contracts/CoreCollection.sol (line [279](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L279))

            for (uint256 i = 0; i < _amount; i++) {

2.  File: core-contracts/contracts/CoreFactory.sol (line [79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L79))

        for (uint256 i; i < _collections.length; i++) {

3.  File: splits/contracts/Splitter.sol (line [50](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L50))

            for (uint256 i = 0; i < currentWindow; i++) {

4.  File: splits/contracts/Splitter.sol (line [274](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L274))

            for (uint256 i = 0; i < proof.length; i++) {

[](#g-12-usage-of-uintsints-smaller-than-32-bytes-256-bits-incurs-overhead)\[G-12\] Usage of `uints`/`ints` smaller than 32 bytes (256 bits) incurs overhead
------------------------------------------------------------------------------------------------------------------------------------------------------------

> When using elements that are smaller than 32 bytes, your contract’s gas usage may be higher. This is because the EVM operates on 32 bytes at a time. Therefore, if the element is smaller than that, the EVM must use more operations in order to reduce the size of the element from 32 bytes to the desired size.

[https://docs.soliditylang.org/en/v0.8.11/internals/layout\_in\_storage.html](https://docs.soliditylang.org/en/v0.8.11/internals/layout_in_storage.html) Use a larger size then downcast where needed

1.  File: splits/contracts/Splitter.sol (line [217](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217))

        function amountFromPercent(uint256 amount, uint32 percent)

[](#g-13-using-private-rather-than-public-for-constants-saves-gas)\[G-13\] Using `private` rather than `public` for constants, saves gas
----------------------------------------------------------------------------------------------------------------------------------------

If needed, the value can be read from the verified contract source code

1.  File: splits/contracts/Splitter.sol (line [14](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14))

        uint256 public constant PERCENTAGE_SCALE = 10e5;

2.  File: splits/contracts/Splitter.sol (line [15](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L15))

        bytes4 public constant IID_IROYALTY = type(IRoyaltyVault).interfaceId;

[](#g-14-dont-compare-boolean-expressions-to-boolean-literals)\[G-14\] Don’t compare boolean expressions to boolean literals
----------------------------------------------------------------------------------------------------------------------------

`if (<x> == true)` => `if (<x>)`, `if (<x> == false)` => `if (!<x>)`

1.  File: royalty-vault/contracts/RoyaltyVault.sol (line [44](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L44))

                IERC20(royaltyAsset).transfer(splitterProxy, splitterShare) == true,

2.  File: royalty-vault/contracts/RoyaltyVault.sol (line [48](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L48))

                ISplitter(splitterProxy).incrementWindow(splitterShare) == true,

3.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [52-55](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L52-L55))

                IERC20(royaltyAsset).transfer(
                    platformFeeRecipient,
                    platformShare
                ) == true,

[](#g-15-remove-unused-variables)\[G-15\] Remove unused variables
-----------------------------------------------------------------

1.  File: splits/contracts/Splitter.sol (line [14](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L14))

        uint256 public constant PERCENTAGE_SCALE = 10e5;

[](#g-16-state-variables-only-set-in-the-constructor-should-be-declared-immutable)\[G-16\] State variables only set in the constructor should be declared `immutable`
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  File: royalty-vault/contracts/ProxyVault.sol (line [9](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/ProxyVault.sol#L9))

        address internal royaltyVault;

[](#g-17-require-or-revert-statements-that-check-input-arguments-should-be-at-the-top-of-the-function)\[G-17\] `require()` or `revert()` statements that check input arguments should be at the top of the function
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  File: splits/contracts/Splitter.sol (line [164](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L164))

            require(royaltyAmount > 0, "No additional funds for window");

[](#g-18-private-functions-not-called-by-the-contract-should-be-removed-to-save-deployment-gas)\[G-18\] `private` functions not called by the contract should be removed to save deployment gas
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  File: splits/contracts/Splitter.sol (lines [217-220](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L217-L220))

        function amountFromPercent(uint256 amount, uint32 percent)
            private
            pure
            returns (uint256)

2.  File: splits/contracts/Splitter.sol (lines [248-250](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol#L248-L250))

        function attemptETHTransfer(address to, uint256 value)
            private
            returns (bool)

[](#g-19-public-functions-not-called-by-the-contract-should-be-declared-external-instead)\[G-19\] `public` functions not called by the contract should be declared `external` instead
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Contracts [are allowed](https://docs.soliditylang.org/en/latest/contracts.html#function-overriding) to override their parents’ functions and change the visibility from `external` to `public`.

1.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [95-100](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L95-L100))

        function supportsInterface(bytes4 interfaceId)
            public
            view
            virtual
            override(IRoyaltyVault, ERC165)
            returns (bool)

2.  File: royalty-vault/contracts/RoyaltyVault.sol (line [88](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L88))

        function getSplitter() public view override returns (address) {

[](#g-20-use-custom-errors-rather-than-revertrequire-strings-to-save-deployment-gas)\[G-20\] Use custom errors rather than `revert()`/`require()` strings to save deployment gas
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

1.  File: royalty-vault/contracts/RoyaltyVault.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol))
2.  File: splits/contracts/SplitFactory.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol))
3.  File: splits/contracts/Splitter.sol (Various lines throughout the [file](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/Splitter.sol))

[](#g-21-functions-guaranteed-to-revert-when-called-by-normal-users-can-be-marked-payable)\[G-21\] Functions guaranteed to revert when called by normal users can be marked `payable`
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

If a function modifier such as `onlyOwner` is used, the function will revert if a normal user tries to pay the function. Marking the function as `payable` will lower the gas cost for legitimate callers because the compiler will not include checks for whether a payment was provided.

1.  File: core-contracts/contracts/CoreCollection.sol (lines [78-87](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L87))

        function initialize(
            string memory _collectionName,
            string memory _collectionSymbol,
            string memory _collectionURI,
            uint256 _maxSupply,
            uint256 _mintFee,
            address _payableToken,
            bool _isForSale,
            address _splitFactory
        ) external onlyOwner onlyValidSupply(_maxSupply) {

2.  File: core-contracts/contracts/CoreCollection.sol (lines [78-87](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L78-L87))

        function initialize(
            string memory _collectionName,
            string memory _collectionSymbol,
            string memory _collectionURI,
            uint256 _maxSupply,
            uint256 _mintFee,
            address _payableToken,
            bool _isForSale,
            address _splitFactory
        ) external onlyOwner onlyValidSupply(_maxSupply) {

3.  File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109))

        function initializeClaims(bytes32 _root)
            external
            onlyOwner
            onlyNotClaimableSet
            onlyValidRoot(_root)

4.  File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109))

        function initializeClaims(bytes32 _root)
            external
            onlyOwner
            onlyNotClaimableSet
            onlyValidRoot(_root)

5.  File: core-contracts/contracts/CoreCollection.sol (lines [105-109](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L105-L109))

        function initializeClaims(bytes32 _root)
            external
            onlyOwner
            onlyNotClaimableSet
            onlyValidRoot(_root)

6.  File: core-contracts/contracts/CoreCollection.sol (lines [121-124](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L121-L124))

        function setCollectionMeta(
            string memory _collectionName,
            string memory _collectionSymbol
        ) external onlyOwner {

7.  File: core-contracts/contracts/CoreCollection.sol (lines [139-145](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L139-L145))

        function mintToken(
            address to,
            bool isClaim,
            uint256 claimableAmount,
            uint256 amount,
            bytes32[] calldata merkleProof
        ) external onlyInitialized {

8.  File: core-contracts/contracts/CoreCollection.sol (line [173](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L173))

        function withdraw() external onlyOwner {

9.  File: core-contracts/contracts/CoreCollection.sol (lines [185-187](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L185-L187))

        function setRoyaltyVault(address _royaltyVault)
            external
            onlyVaultUninitialized

10.  File: core-contracts/contracts/CoreCollection.sol (line [203](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreCollection.sol#L203))

        function setHashedProof(string calldata _proof) external onlyOwner {

11.  File: core-contracts/contracts/CoreFactory.sol (lines [70-73](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L70-L73))

      function createProject(
        string memory _projectId,
        Collection[] memory _collections
      ) external onlyAvailableProject(_projectId) {

12.  File: core-contracts/contracts/CoreFactory.sol (lines [108-111](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L108-L111))

      function addCollection(
        string memory _projectId,
        Collection memory _collection
      ) external onlyProjectOwner(_projectId) returns (address) {

13.  File: core-contracts/contracts/CoreFactory.sol (lines [142-145](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/core-contracts/contracts/CoreFactory.sol#L142-L145))

      function _createCollection(Collection memory _collection)
        private
        onlyAvailableCollection(_collection.id)
        returns (address)

14.  File: royalty-vault/contracts/RoyaltyVault.sol (line [67](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L67))

        function setPlatformFee(uint256 _platformFee) external override onlyOwner {

15.  File: royalty-vault/contracts/RoyaltyVault.sol (lines [76-79](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/royalty-vault/contracts/RoyaltyVault.sol#L76-L79))

        function setPlatformFeeRecipient(address _platformFeeRecipient)
            external
            override
            onlyOwner

16.  File: splits/contracts/SplitFactory.sol (lines [75-80](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L75-L80))

      function createSplit(
        bytes32 _merkleRoot,
        address _splitAsset,
        address _collectionContract,
        string memory _splitId
      ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {

17.  File: splits/contracts/SplitFactory.sol (lines [102-106](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L102-L106))

      function createSplit(
        bytes32 _merkleRoot,
        address _splitAsset,
        string memory _splitId
      ) external onlyAvailableSplit(_splitId) returns (address splitProxy) {

18.  File: splits/contracts/SplitFactory.sol (lines [120-122](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L120-L122))

      function setPlatformFee(address _vault, uint256 _platformFee)
        external
        onlyOwner

19.  File: splits/contracts/SplitFactory.sol (lines [132-135](https://github.com/code-423n4/2022-03-joyn/blob/c9297ccd925ebb2c44dbc6eaa3effd8db5d2368a/splits/contracts/SplitFactory.sol#L132-L135))

      function setPlatformFeeRecipient(
        address _vault,
        address _platformFeeRecipient
      ) external onlyOwner {

**[sofianeOuafir (Joyn) confirmed and commented](https://github.com/code-423n4/2022-03-joyn-findings/issues/56#issuecomment-1100207292):**

> high quality report

* * *

[](#disclosures)Disclosures
===========================

C4 is an open organization governed by participants in the community.

C4 Contests incentivize the discovery of exploits, vulnerabilities, and bugs in smart contracts. Security researchers are rewarded at an increasing rate for finding higher-risk issues. Contest submissions are judged by a knowledgeable security researcher and solidity developer and disclosed to sponsoring developers. C4 does not conduct formal verification regarding the provided code but instead provides final verification.

C4 does not provide any guarantee or warranty regarding the security of this project. All smart contract software should be used at the sole risk and responsibility of users.

.grvsc-container { overflow: auto; position: relative; -webkit-overflow-scrolling: touch; padding-top: 1rem; padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem)); padding-bottom: 1rem; padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem)); border-radius: 8px; border-radius: var(--grvsc-border-radius, 8px); font-feature-settings: normal; line-height: 1.4; } .grvsc-code { display: table; } .grvsc-line { display: table-row; box-sizing: border-box; width: 100%; position: relative; } .grvsc-line > \* { position: relative; } .grvsc-gutter-pad { display: table-cell; padding-left: 0.75rem; padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2); } .grvsc-gutter { display: table-cell; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .grvsc-gutter::before { content: attr(data-content); } .grvsc-source { display: table-cell; padding-left: 1.5rem; padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)); padding-right: 1.5rem; padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem)); } .grvsc-source:empty::after { content: ' '; -webkit-user-select: none; -moz-user-select: none; user-select: none; } .grvsc-gutter + .grvsc-source { padding-left: 0.75rem; padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2); } /\* Line transformer styles \*/ .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before { content: ' '; position: absolute; width: 100%; } .grvsc-line-diff-add::before { background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2)); } .grvsc-line-diff-del::before { background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2)); } .grvsc-line-number { padding: 0 2px; text-align: right; opacity: 0.7; } .dark-default-dark { background-color: #1E1E1E; color: #D4D4D4; } .dark-default-dark .mtk1 { color: #D4D4D4; } .dark-default-dark .mtk4 { color: #569CD6; } .dark-default-dark .mtk11 { color: #DCDCAA; } .dark-default-dark .mtk12 { color: #9CDCFE; } .dark-default-dark .mtk7 { color: #B5CEA8; } .dark-default-dark .mtk8 { color: #CE9178; } .dark-default-dark .mtk10 { color: #4EC9B0; } .dark-default-dark .mtk15 { color: #C586C0; } .dark-default-dark .mtk3 { color: #6A9955; } .dark-default-dark .grvsc-line-highlighted::before { background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1)); box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5)); }